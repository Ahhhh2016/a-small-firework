<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Fireworks</title>
    <style>
        /* Base Reset */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Night Sky Background
           Using a radial gradient to mimic a glow from the city lights below 
           fading into deep space.
        */
        body {
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Interaction Zone (Left Edge) */
        #trigger-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 30px; /* Width of the sensitive area */
            height: 100%;
            z-index: 100;
            background: transparent;
        }

        /* Sidebar Menu */
        #sidebar {
            position: absolute;
            top: 0;
            left: -220px; /* Hidden by default */
            width: 220px;
            height: 100%;
            background: rgba(255, 255, 255, 0.05); /* Very transparent */
            backdrop-filter: blur(10px); /* Glass effect */
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 99;
            padding-top: 60px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Show sidebar when trigger zone is hovered or sidebar is hovered */
        #trigger-zone:hover ~ #sidebar,
        #sidebar:hover {
            left: 0;
        }

        .menu-title {
            text-align: center;
            font-size: 1.1rem;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .menu-tagline {
            text-align: center;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 25px;
            font-style: italic;
            font-family: 'Georgia', serif;
            padding: 0 10px;
        }

        /* Transparent Buttons */
        .fw-option {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            padding: 15px 20px;
            margin: 0 20px;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        .fw-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
            color: #fff;
            padding-left: 25px; /* Slide text slightly */
        }

        .fw-option.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: #a8c0ff;
            color: #fff;
            box-shadow: 0 0 15px rgba(168, 192, 255, 0.2);
        }

        /* Special style for the auto-play button to differentiate it slightly */
        #btn-autoplay {
            margin-top: 25px; /* More separation from manual options */
            border-color: rgba(255, 220, 100, 0.3); /* Warm gold border */
            color: rgba(255, 235, 180, 0.9); /* Warm text color */
            font-family: 'Georgia', serif; /* Serif font for a literary feel */
            font-style: italic;
            transition: all 0.5s ease;
        }

        #btn-autoplay:hover {
            background: rgba(255, 220, 100, 0.1);
            border-color: rgba(255, 220, 100, 0.6);
            color: #fff;
            padding-left: 25px;
        }

        #btn-autoplay.active {
            background: rgba(255, 220, 100, 0.15);
            border-color: rgba(255, 220, 100, 1);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 200, 50, 0.15);
            text-shadow: 0 0 5px rgba(255, 200, 50, 0.5);
        }

        /* Help Text */
        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            color: rgba(255, 240, 220, 0.9); /* Warm candlelight color */
            pointer-events: none;
            z-index: 5;
            font-family: 'Georgia', 'Times New Roman', serif; /* Classical, warm feel */
            font-size: 1.5rem;
            font-style: italic;
            letter-spacing: 1px;
            text-shadow: 0 0 15px rgba(255, 200, 100, 0.2);
            opacity: 0;
            animation: warmFade 6s ease-out forwards;
        }

        #hint span {
            display: block;
            margin-top: 10px;
            font-size: 1rem;
            font-family: 'Segoe UI', sans-serif;
            opacity: 0.7;
            font-style: normal;
            letter-spacing: 0.5px;
        }

        @keyframes warmFade {
            0% { opacity: 0; transform: translate(-50%, -40%); }
            15% { opacity: 1; transform: translate(-50%, -50%); }
            70% { opacity: 1; transform: translate(-50%, -50%); }
            100% { opacity: 0; transform: translate(-50%, -60%); }
        }

    </style>
</head>
<body>

    <!-- Three.js Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="trigger-zone"></div>
    
    <div id="sidebar">
        <div class="menu-title">A Small Firework</div>
        <div class="menu-tagline">For quiet nights like this.</div>
        <!-- Manual Options -->
        <button class="fw-option" id="opt-spark" onclick="setFireworkType('spark')">One Spark</button>
        <button class="fw-option active" id="opt-bloom" onclick="setFireworkType('bloom')">Bloom</button>
        <button class="fw-option" id="opt-drift" onclick="setFireworkType('drift')">Drift</button>
        <button class="fw-option" id="opt-scatter" onclick="setFireworkType('scatter')">Scatter</button>
        
        <!-- Auto Play Option -->
        <button class="fw-option" id="btn-autoplay" onclick="toggleAutoPlay()">Stay and watch</button>
    </div>

    <div id="hint">
        Light one anywhere.
        <span>The menu is on the left.</span>
    </div>

    <!-- Import Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. Global Variables & Setup ---
        let scene, camera, renderer;
        let fireworks = [];
        let particles = [];
        let raycaster, mouse;
        
        // Systems
        let trailSystem;
        let audioCtx; // Audio Context
        
        // Configuration
        let currentType = 'bloom';
        
        // Auto Play State
        let isAutoPlay = false;
        let autoPlayTimer = 0;
        
        // Texture cache
        let particleTexture;

        // --- 2. Class Definitions ---

        class FireworkTrailSystem {
            constructor(scene, texture) {
                this.maxParticles = 10000;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.maxParticles * 3);
                this.colors = new Float32Array(this.maxParticles * 3);
                this.opacities = new Float32Array(this.maxParticles);
                this.sizes = new Float32Array(this.maxParticles);
                
                this.count = 0;
                this.index = 0; // Circular buffer index

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.opacities, 1));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

                // Shader Material
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        pointTexture: { value: texture }
                    },
                    vertexShader: `
                        attribute float alpha;
                        attribute float size;
                        varying vec3 vColor;
                        varying float vAlpha;
                        void main() {
                            vColor = color;
                            vAlpha = alpha;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D pointTexture;
                        varying vec3 vColor;
                        varying float vAlpha;
                        void main() {
                            gl_FragColor = vec4(vColor, vAlpha);
                            gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    vertexColors: true
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; 
                scene.add(this.mesh);
            }

            add(position, color, size = 1.0) {
                const i = this.index;
                const idx3 = i * 3;

                this.positions[idx3] = position.x;
                this.positions[idx3 + 1] = position.y;
                this.positions[idx3 + 2] = position.z;

                this.colors[idx3] = color.r;
                this.colors[idx3 + 1] = color.g;
                this.colors[idx3 + 2] = color.b;

                this.opacities[i] = 1.0;
                this.sizes[i] = size;

                this.index = (this.index + 1) % this.maxParticles;
                if (this.count < this.maxParticles) this.count++;
            }

            update() {
                // Decay opacities
                for (let i = 0; i < this.maxParticles; i++) {
                    if (this.opacities[i] > 0) {
                        this.opacities[i] *= 0.94; 
                        if (this.opacities[i] < 0.01) this.opacities[i] = 0;
                    }
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        class Firework {
            constructor(targetPosition, type) {
                this.isExploded = false;
                this.type = type;
                
                // Start position
                const startX = (Math.random() - 0.5) * 10;
                this.position = new THREE.Vector3(startX, -30, 0);
                this.target = targetPosition;
                
                // Reduced speed for slow ascent
                const speed = 0.4;
                this.velocity = new THREE.Vector3()
                    .subVectors(this.target, this.position)
                    .normalize()
                    .multiplyScalar(speed); 

                // Geometry
                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([0, 0, 0]);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    map: particleTexture,
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                    transparent: true,
                    opacity: 1,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.rocket = new THREE.Points(geometry, material);
                this.rocket.position.copy(this.position);
                scene.add(this.rocket);
                
                this.color = material.color;
                
                // Play Launch Sound
                if(audioCtx) playSoftLaunch();
            }

            update() {
                if (!this.isExploded) {
                    const distanceToTarget = this.rocket.position.distanceTo(this.target);
                    const stepSize = this.velocity.length();

                    // TRAIL EFFECT: One Spark leaves a dense trail
                    if (this.type === 'spark') {
                        trailSystem.add(this.rocket.position, this.color, 1.2);
                    }

                    if (distanceToTarget <= stepSize) {
                        this.rocket.position.copy(this.target);
                        this.explode();
                    } else {
                        this.rocket.position.add(this.velocity);
                        // Standard trail for others
                        if (this.type !== 'spark' && Math.random() > 0.3) {
                            // Minimal trail for non-spark
                        }
                    }
                }
            }

            explode() {
                this.isExploded = true;
                scene.remove(this.rocket);
                createExplosion(this.target, this.type, this.color);
            }
        }

        // --- 3. Functions ---

        function init() {
            // Container
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111116, 0.002);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);
            camera.lookAt(0, 10, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // AutoClear is true, we manage trails via the system, not buffer clearing
            container.appendChild(renderer.domElement);

            // Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Textures
            particleTexture = createParticleTexture();

            // Initialize Custom Trail System
            trailSystem = new FireworkTrailSystem(scene, particleTexture);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('pointerdown', onPointerDown, false);
            
            // Mobile Sidebar Helper
            const trigger = document.getElementById('trigger-zone');
            const sidebar = document.getElementById('sidebar');
            trigger.addEventListener('touchstart', () => sidebar.style.left = '0');
            document.addEventListener('touchstart', (e) => {
                if(e.clientX > 220) sidebar.style.left = '-220px';
            });
        }
        
        // --- Sound Functions ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSoftLaunch() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const noise = ctx.createBufferSource();
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < data.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            noise.buffer = buffer;

            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(300, ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(3000, ctx.currentTime + 0.4);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.2);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);

            noise.connect(filter).connect(gain).connect(ctx.destination);
            noise.start();
        }

        function playSparkle() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'triangle';
            osc.frequency.value = 1200 + Math.random() * 800;

            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.03, ctx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);

            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
        }

        function playSoftBloom() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const now = ctx.currentTime;

            for (let i = 0; i < 6; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'sine';
                osc.frequency.value = 400 + Math.random() * 1200;

                gain.gain.setValueAtTime(0.001, now);
                gain.gain.exponentialRampToValueAtTime(0.08, now + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

                osc.connect(gain).connect(ctx.destination);
                osc.start(now + i * 0.015);
                osc.stop(now + 0.8);
            }
        }

        function playShimmer() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'triangle';
            osc.frequency.value = 1800;

            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.05, ctx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);

            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 1.5);
        }

        function playSoftCrackle() {
            if (!audioCtx) return;
            if (Math.random() > 0.4) return;

            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.type = 'square';
            osc.frequency.value = 2000 + Math.random() * 1000;

            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.015, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);

            osc.connect(gain).connect(ctx.destination);
            osc.start();
            osc.stop(ctx.currentTime + 0.12);
        }


        function createExplosion(position, type, color) {
            
            // Play Sound based on type
            if(audioCtx) {
                if (type === 'bloom') playSoftBloom();
                else if (type === 'drift') playShimmer();
                else if (type === 'scatter') {
                     // For scatter, simulate a small burst of crackles
                     for(let k=0; k<5; k++) setTimeout(playSoftCrackle, Math.random() * 200);
                }
                else if (type === 'spark') {
                    // For spark, simulate a dense burst of crackles
                     for(let k=0; k<8; k++) setTimeout(playSoftCrackle, Math.random() * 300);
                }
            }
            
            let particleCount = 0;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];
            const sizes = [];
            const decays = [];
            const targetSizes = []; 

            let baseSpeed = 0.5;
            
            switch (type) {
                case 'spark':
                    particleCount = 100; 
                    baseSpeed = 0.2; 
                    break;
                case 'bloom':
                    particleCount = 200; 
                    baseSpeed = 0.15; 
                    break;
                case 'drift':
                    particleCount = 100;
                    baseSpeed = 0.08; 
                    break;
                case 'scatter':
                    particleCount = 80;
                    baseSpeed = 0.25; 
                    break;
            }

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);

                // Initialize Color
                const c = new THREE.Color().copy(color);
                c.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
                colors.push(c.r, c.g, c.b);

                const v = new THREE.Vector3();
                
                if (type === 'bloom') {
                    const phi = Math.PI * (3 - Math.sqrt(5)); 
                    const y = 1 - (i / (particleCount - 1)) * 2; 
                    const radius = Math.sqrt(1 - y * y);
                    const theta = phi * i;
                    v.x = Math.cos(theta) * radius * baseSpeed;
                    v.y = y * baseSpeed;
                    v.z = Math.sin(theta) * radius * baseSpeed;
                } 
                else if (type === 'spark') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * baseSpeed;
                    v.x = r * Math.sin(phi) * Math.cos(theta);
                    v.y = r * Math.sin(phi) * Math.sin(theta);
                    v.z = r * Math.cos(phi);
                }
                else if (type === 'drift') {
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.random() * baseSpeed;
                    v.x = r * Math.cos(theta) * 2; 
                    v.y = (Math.random() - 0.2) * 0.5; 
                    v.z = r * Math.sin(theta) * 2;
                }
                else {
                    v.set((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2)
                     .normalize().multiplyScalar(Math.random() * baseSpeed * 2);
                }

                // Reduced upward momentum for the slower scale
                velocities.push(v.x, v.y + 0.12, v.z);
                
                const finalSize = (Math.random() * 1.5 + 0.5) * (type === 'spark' ? 2 : 1);
                targetSizes.push(finalSize);
                
                if (type === 'bloom') sizes.push(0.1); 
                else sizes.push(finalSize);

                // Slower decay
                decays.push(0.0008 + Math.random() * 0.003);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.0,
                map: particleTexture,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            particles.push({
                mesh: particleSystem,
                velocities: velocities,
                targetSizes: targetSizes,
                decays: decays,
                type: type,
                life: 1.0,
                age: 0
            });
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Toggle Auto Play Function ---
        function toggleAutoPlay() {
            // Initialize audio on click interaction
            initAudio();
            
            isAutoPlay = !isAutoPlay;
            
            const btnAuto = document.getElementById('btn-autoplay');
            const manualBtns = document.querySelectorAll('.fw-option:not(#btn-autoplay)');
            
            // Clear manual selection visuals
            manualBtns.forEach(b => b.classList.remove('active'));
            
            if (isAutoPlay) {
                btnAuto.classList.add('active');
                btnAuto.innerText = "Pause"; // Change text to Pause
                autoPlayTimer = 30; // Start almost immediately
            } else {
                btnAuto.classList.remove('active');
                btnAuto.innerText = "Stay and watch"; // Revert text
                // Re-highlight the last selected manual type
                const currentBtn = document.getElementById('opt-' + currentType);
                if(currentBtn) currentBtn.classList.add('active');
            }
        }

        function setFireworkType(type) {
            // Initialize audio on click interaction
            initAudio();
            
            // Turning on manual type disables auto play
            isAutoPlay = false;
            currentType = type;
            
            const btnAuto = document.getElementById('btn-autoplay');
            btnAuto.classList.remove('active');
            btnAuto.innerText = "Stay and watch"; // Reset text if user clicks other options
            
            const buttons = document.querySelectorAll('.fw-option:not(#btn-autoplay)');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const activeBtn = document.getElementById('opt-' + type);
            if(activeBtn) activeBtn.classList.add('active');
        }
        
        function launchRandomFirework() {
            const types = ['spark', 'bloom', 'drift', 'scatter'];
            const randomType = types[Math.floor(Math.random() * types.length)];
            
            // Random position in the sky (center focused but spread out)
            const x = (Math.random() - 0.5) * 12; // Spread -6 to 6
            const y = Math.random() * 8 + 4; // Height 4 to 12
            const target = new THREE.Vector3(x, y, 0);
            
            fireworks.push(new Firework(target, randomType));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            // Initialize Audio
            initAudio();

            if (event.clientX < 220 && document.getElementById('sidebar').style.left === '0px') return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeZ, target);
            if(target) fireworks.push(new Firework(target, currentType));
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- Auto Play Logic ---
            if (isAutoPlay) {
                // Occasional ambient sparkle sound in auto-show mode
                if (Math.random() < 0.01) playSparkle();

                autoPlayTimer--;
                if (autoPlayTimer <= 0) {
                    launchRandomFirework();
                    // Next firework in 60 to 180 frames (approx 1-3 seconds)
                    autoPlayTimer = Math.random() * 120 + 60;
                }
            }

            // Update Trail System
            trailSystem.update();

            // 1. Update Rocket Fireworks
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                if (fireworks[i].isExploded) fireworks.splice(i, 1);
            }

            // 2. Update Explosion Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const positions = p.mesh.geometry.attributes.position.array;
                const sizes = p.mesh.geometry.attributes.size.array;
                const colors = p.mesh.geometry.attributes.color.array;
                
                // Physics Config
                let drag = 0.99; 
                let grav = -0.006; 

                if (p.type === 'bloom') { drag = 0.985; grav = -0.004; }
                else if (p.type === 'drift') { drag = 0.98; grav = -0.001; }
                else if (p.type === 'scatter') { drag = 0.995; }

                p.age++;

                for (let j = 0; j < p.velocities.length; j += 3) {
                    const vertexIndex = j / 3;

                    // Gravity & Drag
                    p.velocities[j + 1] += grav;
                    p.velocities[j] *= drag;
                    p.velocities[j + 1] *= drag;
                    p.velocities[j + 2] *= drag;

                    // Update Position
                    positions[j] += p.velocities[j];
                    positions[j + 1] += p.velocities[j + 1];
                    positions[j + 2] += p.velocities[j + 2];

                    // TRAIL EFFECT: If "Spark", particles emit trails
                    if (p.type === 'spark' && p.life > 0.2) {
                        const pos = new THREE.Vector3(positions[j], positions[j+1], positions[j+2]);
                        const col = new THREE.Color(colors[j], colors[j+1], colors[j+2]);
                        trailSystem.add(pos, col, 0.5);
                    }

                    // BLOSSOM ANIMATION
                    if (p.type === 'bloom' && p.age < 60) {
                        const targetSize = p.targetSizes[vertexIndex];
                        const progress = p.age / 60;
                        const ease = 1 - Math.pow(1 - progress, 3);
                        sizes[vertexIndex] = targetSize * ease;
                    }
                }

                // Slower life decay
                p.life -= 0.002; 
                p.mesh.material.opacity = p.life;

                p.mesh.geometry.attributes.position.needsUpdate = true;
                if (p.type === 'bloom') p.mesh.geometry.attributes.size.needsUpdate = true;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        // --- 4. Execution ---
        init();
        animate();
    </script>
</body>
</html>