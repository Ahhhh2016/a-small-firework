<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A Small Firework</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    <!-- Import Cuprum Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cuprum:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
    
    <style>
        /* Base Reset */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Cuprum', sans-serif;
        }

        /* Night Sky Background */
        body {
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Interaction Zone (Left Edge) */
        #trigger-zone {
            position: absolute;
            top: 0;
            left: 0;
            width: 30px;
            height: 100%;
            z-index: 100;
            background: transparent;
        }

        /* Sidebar Menu */
        #sidebar {
            position: absolute;
            top: 0;
            left: -220px;
            width: 220px;
            height: 100%;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: left 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 99;
            padding-top: 60px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 15px;
			overflow-y: auto;
			overflow-x: hidden;
			scrollbar-width: thin; /* Firefox */
			scrollbar-color: rgba(255, 255, 255, 0.3) transparent; /* Firefox */
			scrollbar-gutter: stable;
        }

		/* Night-sky themed thin scrollbar (WebKit) */
		#sidebar::-webkit-scrollbar {
			width: 4px;
		}
		#sidebar::-webkit-scrollbar-track {
			background: transparent;
		}
		#sidebar::-webkit-scrollbar-thumb {
			background-color: rgba(255, 255, 255, 0.2);
			border-radius: 4px;
		}
        #trigger-zone:hover ~ #sidebar,
        #sidebar:hover {
            left: 0;
        }

        .menu-title {
			text-align: right;
            font-size: 1.3rem;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.9);
			margin: 0 20px 5px 20px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .menu-tagline {
			text-align: right;
            font-size: 1.0rem;
            color: rgba(255, 255, 255, 0.5);
			margin: 0 20px 25px 20px;
            font-style: italic;
            font-family: 'Cuprum', sans-serif;
			padding: 0;
        }

        /* Transparent Buttons */
        .fw-option {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            padding: 15px 20px;
            margin: 0 20px;
            border-radius: 8px;
            cursor: pointer;
            text-align: left;
            transition: all 0.3s ease;
            font-size: 1.1rem;
            position: relative;
            overflow: hidden;
            font-family: 'Cuprum', sans-serif;
			display: flex;
			align-items: center;
        }

        .fw-option:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
            color: #fff;
            padding-left: 25px;
        }

        .fw-option.active {
            background: rgba(255, 255, 255, 0.15);
            border-color: #a8c0ff;
            color: #fff;
            box-shadow: 0 0 15px rgba(168, 192, 255, 0.2);
        }

        /* Special style for the auto-play button */
        #btn-autoplay {
            margin-top: 25px;
            border-color: rgba(255, 220, 100, 0.3);
            color: rgba(255, 235, 180, 0.9);
            font-family: 'Cuprum', sans-serif;
            font-style: italic;
            transition: all 0.5s ease;
        }

        #btn-autoplay:hover {
            background: rgba(255, 220, 100, 0.1);
            border-color: rgba(255, 220, 100, 0.6);
            color: #fff;
            padding-left: 25px;
        }

        #btn-autoplay.active {
            background: rgba(255, 220, 100, 0.15);
            border-color: rgba(255, 220, 100, 1);
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 200, 50, 0.15);
            text-shadow: 0 0 5px rgba(255, 200, 50, 0.5);
        }

        /* Help Text */
        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            text-align: center;
            color: rgba(255, 240, 220, 0.9);
            pointer-events: none;
            z-index: 5;
            font-family: 'Cuprum', sans-serif;
            font-size: 2rem;
            font-style: italic;
            letter-spacing: 1px;
            text-shadow: 0 0 15px rgba(255, 200, 100, 0.2);
            opacity: 0;
            animation: warmFade 6s ease-out forwards;
        }

        #hint span {
            display: block;
            margin-top: 10px;
            font-size: 1.2rem;
            font-family: 'Cuprum', sans-serif;
            opacity: 0.7;
            font-style: normal;
            letter-spacing: 0.5px;
        }

        @keyframes warmFade {
            0% { opacity: 0; transform: translate(-50%, -40%); }
            15% { opacity: 1; transform: translate(-50%, -50%); }
            70% { opacity: 1; transform: translate(-50%, -50%); }
            100% { opacity: 0; transform: translate(-50%, -60%); }
        }

        /* Volume Control Styles */
        .volume-control {
            margin: 20px 20px 0 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .volume-label {
            font-size: 0.95rem;
            letter-spacing: 0.5px;
            color: rgba(255, 255, 255, 0.75);
            text-transform: uppercase;
        }
        .volume-control input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            outline: none;
            margin-top: 10px;
        }
        .volume-control input[type=range]::-webkit-slider-runnable-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }
        .volume-control input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.75);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
            margin-top: -5px;
            cursor: pointer;
        }
        .volume-control input[type=range]::-moz-range-track {
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 2px;
        }
        .volume-control input[type=range]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.75);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
            cursor: pointer;
        }
        .volume-control input[type=range]:focus {
            outline: none;
        }
        .volume-control input[type=range]:hover::-webkit-slider-thumb {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }
        .volume-control input[type=range]:hover::-moz-range-thumb {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }

    </style>
</head>
<body>

    <!-- Three.js Container -->
    <div id="canvas-container"></div>

    <!-- UI Overlay -->
    <div id="trigger-zone"></div>
    
    <div id="sidebar">
        <div class="menu-title">A Small Firework</div>
        <div class="menu-tagline">For quiet nights like this.</div>
        
        <!-- Manual Options -->
        <button class="fw-option" id="opt-spark" onclick="setFireworkType('spark')">One Spark</button>
        <button class="fw-option active" id="opt-bloom" onclick="setFireworkType('bloom')">Bloom</button>
        <button class="fw-option" id="opt-drift" onclick="setFireworkType('drift')">Drift</button>
        <button class="fw-option" id="opt-scatter" onclick="setFireworkType('scatter')">Scatter</button>
        
        <!-- New Sparkler Option -->
        <button class="fw-option" id="opt-sparkler" onclick="launchSparkler()">Sparkler</button>

        <!-- Auto Play Option -->
        <button class="fw-option" id="btn-autoplay" onclick="toggleAutoPlay()">Stay and watch</button>

        <!-- Volume Control Component -->
        <div class="volume-control">
            <div class="volume-label">Volume</div>
            <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.5">
        </div>
    </div>

    <div id="hint">
        Light one anywhere.
        <span>The menu is on the left.</span>
    </div>

    <!-- Import Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. Global Variables & Setup ---
        let scene, camera, renderer;
        let fireworks = [];
        let particles = [];
        let raycaster, mouse;
        
        // Systems
        let trailSystem;
        let sparklerSystem = null; 
        let audioCtx; 
        let masterGainNode; 
        let currentVolume = 0.5; 
        
        // Configuration
        let currentType = 'bloom';
        let isAutoPlay = false;
        let autoPlayTimer = 0;
        let sparklerActive = false;
        
        // Texture cache
        let particleTexture;

        // Sparkler constants (mirror shader values)
        const SPARKLER_BURN_START_Y = 2.2;
        const SPARKLER_BURN_SPEED = 0.25;
        const SPARKLER_TIME_SCALE = 1.5;

        // --- 2. Shader Code for Sparkler ---
        // UPDATED: Visible Paper Texture & Fixed FBM overloading
        const sparklerFragmentShader = `
        uniform float iTime;
        uniform vec2 iResolution;
        varying vec2 vUv;

        // Int constants for loops
        #define NUM_SPARKLES 100
        #define NUM_SUB_SPARKLES 3
        
        #define SUB_SPARKLE_CHANCE .4
        #define PRIMARY_PARTICLE_COLOR vec3(1., 0.8, 0.5)
        #define SECONDARY_PARTICLE_COLOR vec3(1., 0.5, 0.3)
        #define DOF vec2(1., 1.5)
        // Global size multiplier for sparkler particles
        #define SPARK_SIZE_MULT 2.0
        
        // Camera Config
        #define MIN_CAM_DISTANCE 1.5
        #define MAX_CAM_DISTANCE 7.
        
        // Speed Config: Starts at Y=2.2, moves down at 0.25 units/sec
        #define BURN_START_Y 2.2
        #define BURN_SPEED 0.25

        #define PI 3.1415
        #define saturate(x) clamp(x,0.,1.)

        float DistSqr(vec3 a, vec3 b) { vec3 D=a-b; return dot(D, D); } 

        const vec3 up = vec3(0.,1.,0.);

        #define MOD3 vec3(.1031,.11369,.13787)
        vec3 hash31(float p) {
           vec3 p3 = fract(vec3(p) * MOD3);
           p3 += dot(p3, p3.yzx + 19.19);
           return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));
        }
        
        // 3D Value Noise
        float hash(vec3 p) {
            p  = fract( p*0.3183099+.1 );
            p *= 17.0;
            return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );
        }
        float noise(vec3 x) {
            vec3 i = floor(x);
            vec3 f = fract(x);
            f = f*f*(3.0-2.0*f);
            return mix(mix(mix( hash(i+vec3(0,0,0)), hash(i+vec3(1,0,0)),f.x),
                           mix( hash(i+vec3(0,1,0)), hash(i+vec3(1,1,0)),f.x),f.y),
                       mix(mix( hash(i+vec3(0,0,1)), hash(i+vec3(1,0,1)),f.x),
                           mix( hash(i+vec3(0,1,1)), hash(i+vec3(1,1,1)),f.x),f.y),f.z);
        }

        // FBM for vec3 (renamed from fbm to fbm3)
        float fbm3(vec3 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 4; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // FBM for vec2 (renamed from fbm to fbm2)
        float fbm2(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i = 0; i < 4; i++) {
                v += a * noise(vec3(p, 0.0));
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // Procedural Triplanar Texture Simulation
        // Simulates tex3D(pos, normal, sampler) using noise
        float proceduralTex3D(vec3 pos, vec3 normal, float scale) {
            // Use fbm2 for planar mapping
            float nX = fbm2(pos.yz * scale);
            float nY = fbm2(pos.xz * scale);
            float nZ = fbm2(pos.xy * scale);
            return nX * abs(normal.x) + nY * abs(normal.y) + nZ * abs(normal.z);
        }

        struct ray { vec3 o; vec3 d; };
        struct camera {
            vec3 p; vec3 forward; vec3 left; vec3 up;
            vec3 center; vec3 i; ray ray; vec3 lookAt; float zoom;
        };
        camera cam;

        void CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {
            cam.p = position;
            cam.lookAt = lookAt;
            cam.forward = normalize(cam.lookAt-cam.p);
            cam.left = cross(up, cam.forward);
            cam.up = cross(cam.forward, cam.left);
            cam.zoom = zoom;
            cam.center = cam.p+cam.forward*cam.zoom;
            cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;
            cam.ray.o = cam.p;
            cam.ray.d = normalize(cam.i-cam.p);
        }

        float within(vec2 v, float t) { return (t-v.x) / (v.y-v.x); }

        float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {
            vec3 pa = p-a, ba = b-a;
            float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
            return length( pa - ba*h ) - r;
        }

        // --- SDF & Map ---
        // Returns vec4(distance, bumpValue, burnState, matID)
        vec4 map( in vec3 p) {
            // Calculate Current Burn Y
            float scaledTime = iTime * 1.5;
            float currentBurnY = BURN_START_Y - scaledTime * BURN_SPEED;
            
            // Texture Projection Normal
            vec3 normalApprox = normalize(vec3(p.x, 0.0, p.z));
            
            // 1. New Paper Bump (Fine grain)
            float newBump = proceduralTex3D(p, normalApprox, 60.0) * 0.005;
            
            // 2. Burned Ash Bump (Coarse) - unused now as we discard ash
            float burnedBump = proceduralTex3D(p, normalApprox, 20.0) * 0.06;
            
            // Transition zone logic
            float transition = smoothstep(currentBurnY - 0.2, currentBurnY + 0.2, p.y);
            
            float bump = mix(burnedBump, newBump, transition);
            
            // Apply bump to SDF radius
            // Reduced radius from 0.08 to 0.04 for a thinner stick
            float d = sdCapsule(p, vec3(0., -4., 0.), vec3(0., 4., 0.), 0.04 + bump);
            
            return vec4(d, bump, transition, 1.0);
        }

        // --- Raymarching ---
        vec4 castRay( in vec3 ro, in vec3 rd ) {
            float dmin = 1.0;
            float dmax = 20.0;
            float precis = 0.002;
            float d = dmin;
            float m = -1.0;
            float bumpVal = 0.0;
            float transVal = 0.0;
            
            for( int i=0; i<60; i++ ) {
                vec4 res = map( ro+rd*d );
                if( res.x<precis || d>dmax ) {
                    // Hit!
                    bumpVal = res.y; 
                    transVal = res.z;
                    m = res.w;
                    break; 
                }
                d += res.x;
            }
            if( d>dmax ) m=-1.0;
            // Return d, bump, transition, id
            return vec4( d, bumpVal, transVal, m );
        }

        vec3 calcNormal( in vec3 pos ) {
            vec3 eps = vec3( 0.001, 0.0, 0.0 );
            vec3 nor = vec3(
                map(pos+eps.xyy).x - map(pos-eps.xyy).x,
                map(pos+eps.yxy).x - map(pos-eps.yxy).x,
                map(pos+eps.yyx).x - map(pos-eps.yyx).x );
            return normalize(nor);
        }

        vec3 ClosestPoint(ray r, vec3 p) {
            return r.o + max(0., dot(p-r.o, r.d))*r.d;
        }

        // --- Rendering ---
        vec4 render( in vec3 ro, in vec3 rd, out float d, float currentBurnY ) {
            vec3 col = vec3(0.);
            vec4 res = castRay(ro,rd);
            d = res.x;
            float bumpVal = res.y;
            float transition = res.z; 
            float m = res.w;
            
            float alpha = 0.0;

            if( m>0.5 ) {
                vec3 pos = ro + d*rd;
                
                // Cutoff for disappeared ash
                if (pos.y < currentBurnY + 0.15) {
                    alpha = 1.0;
                    vec3 nor = calcNormal( pos );
                    
                    // --- Material Colors ---
                    // Enhanced Paper Texture using Triplanar noise
                    float tex = proceduralTex3D(pos, nor, 60.0);
                    
                    vec3 paperCol = vec3(0.85, 0.82, 0.75); // Base beige
                    
                    // Fibrous texture: darker strands
                    float fibers = smoothstep(0.4, 0.7, tex);
                    paperCol = mix(paperCol, vec3(0.75, 0.7, 0.6), fibers * 0.5);
                    
                    // Add micro grain
                    float grain = noise(pos * 150.0);
                    paperCol *= (0.95 + 0.1 * grain);

                    // --- Lighting ---
                    vec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );
                    float diff = clamp( dot( nor, lig ), 0.0, 1.0 );
                    float lighting = pow(diff, 0.6); 
                    
                    // Basic lighting
                    col = paperCol * (0.4 + 0.6 * lighting);

                    // --- Burning Glow Effect (Additive) ---
                    float distToBurn = currentBurnY - pos.y; // Positive if below line
                    
                    if (distToBurn > -0.05 && distToBurn < 0.2) {
                        float heat = 1.0 - smoothstep(0.0, 0.2, abs(distToBurn));
                        
                        // Flicker noise
                        float flicker = noise(vec3(0.0, iTime * 10.0, 0.0));
                        heat *= (0.8 + 0.2 * flicker);
                        
                        // Cracks glow brighter
                        float crack = smoothstep(0.4, 0.7, proceduralTex3D(pos, nor, 30.0));
                        
                        vec3 emberColor = vec3(1.0, 0.3, 0.05); // Orange-Red
                        vec3 brightColor = vec3(1.0, 0.8, 0.4); // Yellow-White
                        
                        vec3 glow = mix(emberColor, brightColor, crack * 0.5);
                        
                        col += glow * heat * 3.0;
                    }
                }
            }
            return vec4( saturate(col), alpha );
        }

        vec3 sparkle(ray r, vec3 p, float size, vec3 color) {
            float CAMERA_DISTANCE = length(cam.p);
            float camDist = length(cam.p-p);
            float focus = smoothstep(DOF.y, DOF.x, abs(camDist-CAMERA_DISTANCE));
            vec3 closestPoint = ClosestPoint(r, p);
            float dist = DistSqr(closestPoint, p)*10000.;
            size = mix(size*5., size, focus);
            float brightness = size/dist;
            brightness = clamp(brightness,0., 10.);
            float bokeh = smoothstep(.01, .04, brightness)*saturate(dist*.005+.4)*.15;
            brightness = mix(bokeh, brightness, focus);
            return color * brightness;
        }

        vec3 sparkles(ray r, float time) {
            vec3 col = vec3(0.);
            
            for(int i=0; i<NUM_SPARKLES; i++) {                  
                float fi = float(i);
                float t = time + (fi/float(NUM_SPARKLES));
                float ft = floor(t); 
                float life = fract(t); 
                
                float emissionBurnY = BURN_START_Y - (time - life) * BURN_SPEED; 
                
                vec3 n = hash31(fi + ft*123.324);
                
                // Start close to the burn line with slight jitter
                vec3 pStart = vec3(0., emissionBurnY, 0.) + (n - 0.5) * vec3(0.05, 0.02, 0.05);
                
                // Initial velocity (slightly forward and outward), then apply drag and gravity
                vec3 dir = normalize((n - 0.5) * vec3(1.0, 0.5, 1.0) + vec3(0.1, 0.0, 0.0));
                float speed = mix(0.6, 2.2, n.x);
                vec3 v0 = dir * speed;
                float drag = exp(-life * 2.0);
                vec3 gravity = vec3(0.0, -1.8, 0.0);
                vec3 p = pStart + v0 * life * drag + 0.5 * gravity * (life * life);
                
                if (emissionBurnY > -3.0) {
                    // Lifespan sizing and flicker
                    float size = mix(8., .5, smoothstep(0., .2, life));
                    size *= smoothstep(1., .2, life);
                    float flick = noise(p * 6.0 + vec3(0.0, 0.0, iTime * 24.0));
                    size *= mix(0.85, 1.25, flick);
                    size *= SPARK_SIZE_MULT;
                    
                    // Color temperature progression (white-hot -> warm -> cool)
                    vec3 hot = vec3(1.0, 0.96, 0.88);
                    vec3 warm = vec3(1.0, 0.72, 0.28);
                    vec3 cool = vec3(0.82, 0.32, 0.08);
                    vec3 c1 = mix(warm, hot, smoothstep(0.0, 0.18, 1.0 - life));
                    vec3 c2 = mix(c1, cool, smoothstep(0.5, 1.0, life));

                    // Occasional micro-bursts of sub-sparks
                    if(life > n.z && abs(n.z-.55) < SUB_SPARKLE_CHANCE) {
                        for(int x=0; x<NUM_SUB_SPARKLES; x++) {
                            float fx = float(x);
                            vec3 ns = hash31(fx+fi);
                            // Sub-spark ballistic path
                            float st = saturate(within(vec2(n.z, 1.), life));
                            vec3 dirS = normalize((ns - 0.5) * vec3(1.0, 0.8, 1.0));
                            float spdS = mix(0.4, 1.3, ns.x);
                            vec3 vS = dirS * spdS;
                            vec3 sp = p + vS * st * exp(-st * 2.2) + 0.5 * gravity * (st * st);
                            float sSize = mix(6., 0.4, smoothstep(0., .12, st));
                            sSize *= smoothstep(1., .88, st);
                            sSize *= SPARK_SIZE_MULT;
                            vec3 sc = mix(warm, cool, st);
                            col += sparkle(r, sp, sSize, sc);
                        }
                    } else {
                         col += sparkle(r, p, size, c2);
                    }
                }
            }
            return col;
        }

        // Subtle smoke rising from the burn line (low intensity, soft)
        vec3 smokeClouds(ray r, float time, float currentBurnY) {
            vec3 col = vec3(0.);
            for (int i = 0; i < 12; i++) {
                float fi = float(i);
                float t = time * 0.5 + fi * 0.173;
                float ft = floor(t);
                float life = fract(t);
                vec3 n = hash31(fi + ft * 41.31);
                float rise = mix(0.2, 1.2, life) + n.x * 0.2;
                vec3 jitter = (n - 0.5) * vec3(0.25, 0.15, 0.25);
                vec3 p = vec3(0., currentBurnY + rise, 0.) + jitter;
                float size = mix(40., 12., life);
                float fade = (1.0 - life) * (0.35 + 0.15 * noise(p * 3.0 + vec3(0.0, 0.0, time * 1.3)));
                vec3 smokeCol = vec3(0.34, 0.36, 0.4) * fade;
                col += sparkle(r, p, size, smokeCol);
            }
            return col;
        }

        vec3 Rainbow(vec3 c) {
            float t=iTime;
            c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);
            return c;
        }

        void main() {
            vec2 uv = vUv - 0.5;
            uv.y *= iResolution.y/iResolution.x;
            
            float scaledTime = iTime * 1.5; 
            
            float currentBurnY = BURN_START_Y - scaledTime * BURN_SPEED;
            
            float turn = iTime * 0.1;
            float s = sin(turn);
            float c = cos(turn);
            mat3 rot = mat3(c, 0., s, 0., 1., 0., s, 0., -c);
            
            float CAMERA_DISTANCE = mix(MIN_CAM_DISTANCE, MAX_CAM_DISTANCE, sin(iTime*.0765)*.5+.5);
            vec3 pos = vec3(0., 0.0, -CAMERA_DISTANCE) * rot;
            
            float lookY = clamp(currentBurnY - 1.0, -1.0, 1.0);
            CameraSetup(uv, pos, vec3(0., lookY, 0.), 1.);
            
            float dist;
            vec4 stick = render(cam.ray.o, cam.ray.d, dist, currentBurnY);
            dist += .08; 
            
            vec3 col = vec3(0.);
            
            if (stick.w > 0.0) {
                col = stick.rgb;
            }
            
            vec3 spk = sparkles(cam.ray, scaledTime);
            vec3 smk = smokeClouds(cam.ray, scaledTime, currentBurnY);
            col += spk + smk;
            
            float alpha = max(stick.w, min(1.0, length(spk + smk) * 1.6));
            
            gl_FragColor = vec4(col, alpha);
        }
        `;
        
        const sparklerVertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            // Full Screen Quad
            gl_Position = vec4(position.xy, 0.0, 1.0);
        }
        `;

        // --- 3. Class Definitions ---

        class FireworkTrailSystem {
            constructor(scene, texture) {
                this.maxParticles = 10000;
                this.geometry = new THREE.BufferGeometry();
                this.positions = new Float32Array(this.maxParticles * 3);
                this.colors = new Float32Array(this.maxParticles * 3);
                this.opacities = new Float32Array(this.maxParticles);
                this.sizes = new Float32Array(this.maxParticles);
                this.count = 0;
                this.index = 0;

                this.geometry.setAttribute('position', new THREE.BufferAttribute(this.positions, 3));
                this.geometry.setAttribute('color', new THREE.BufferAttribute(this.colors, 3));
                this.geometry.setAttribute('alpha', new THREE.BufferAttribute(this.opacities, 1));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1));

                const material = new THREE.ShaderMaterial({
                    uniforms: { pointTexture: { value: texture } },
                    vertexShader: `
                        attribute float alpha;
                        attribute float size;
                        varying vec3 vColor;
                        varying float vAlpha;
                        void main() {
                            vColor = color;
                            vAlpha = alpha;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D pointTexture;
                        varying vec3 vColor;
                        varying float vAlpha;
                        void main() {
                            gl_FragColor = vec4(vColor, vAlpha);
                            gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                        }
                    `,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    transparent: true,
                    vertexColors: true
                });

                this.mesh = new THREE.Points(this.geometry, material);
                this.mesh.frustumCulled = false; 
                scene.add(this.mesh);
            }

            add(position, color, size = 1.0) {
                const i = this.index;
                const idx3 = i * 3;
                this.positions[idx3] = position.x;
                this.positions[idx3 + 1] = position.y;
                this.positions[idx3 + 2] = position.z;
                this.colors[idx3] = color.r;
                this.colors[idx3 + 1] = color.g;
                this.colors[idx3 + 2] = color.b;
                this.opacities[i] = 1.0;
                this.sizes[i] = size;
                this.index = (this.index + 1) % this.maxParticles;
                if (this.count < this.maxParticles) this.count++;
            }

            update() {
                for (let i = 0; i < this.maxParticles; i++) {
                    if (this.opacities[i] > 0) {
                        this.opacities[i] *= 0.94; 
                        if (this.opacities[i] < 0.01) this.opacities[i] = 0;
                    }
                }
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.color.needsUpdate = true;
                this.geometry.attributes.alpha.needsUpdate = true;
                this.geometry.attributes.size.needsUpdate = true;
            }
        }

        class SparklerSystem {
            constructor(scene, camera) {
                this.scene = scene;
                this.camera = camera;
                this.mesh = null;
                this.active = false;
                this.startTime = 0;
                // Duration roughly calculated: 
                // Start Y=2.2, Speed 0.25 (scaled by 1.5 in shader = 0.375 eff).
                // Distance to cover ~5 units. Time ~ 14s. Safe 16s.
                this.duration = 16000; 
                this.soundInterval = null;
				this.burnSound = null;

                const geometry = new THREE.PlaneGeometry(2, 2); 
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        iTime: { value: 0 },
                        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    vertexShader: sparklerVertexShader,
                    fragmentShader: sparklerFragmentShader,
                    transparent: true,
                    depthTest: false,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending 
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.renderOrder = 9999;
                this.mesh.frustumCulled = false;
                this.mesh.visible = false;
                
                scene.add(this.mesh);
            }

            start() {
                if (this.active) return;
                this.active = true;
                this.mesh.visible = true;
                this.startTime = performance.now();
                this.mesh.material.uniforms.iTime.value = 0;
                
				if (audioCtx) {
					this.burnSound = startSparklerBurn(audioCtx);
					this.soundInterval = setInterval(() => {
						sparklerCrackle(audioCtx);
					}, 250);
				}

                setTimeout(() => {
                    this.stop();
                }, this.duration);
            }

            stop() {
                this.active = false;
                this.mesh.visible = false;
                if (this.soundInterval) {
                    clearInterval(this.soundInterval);
                    this.soundInterval = null;
                }
				if (this.burnSound) {
					try { this.burnSound.noise.stop(); } catch(e) {}
					try { this.burnSound.noise.disconnect(); } catch(e) {}
					try { this.burnSound.gain.disconnect(); } catch(e) {}
					this.burnSound = null;
				}
                const btn = document.getElementById('opt-sparkler');
                if (btn) btn.classList.remove('active');
            }

            update() {
                if (this.active && this.mesh) {
                    const elapsed = (performance.now() - this.startTime) / 1000;
                    this.mesh.material.uniforms.iTime.value = elapsed;
                    
                    // Vary crackle rate with emission intensity (peaks mid-burn)
                    if (audioCtx) {
                        const scaledTime = elapsed * SPARKLER_TIME_SCALE;
                        const currentBurnY = SPARKLER_BURN_START_Y - scaledTime * SPARKLER_BURN_SPEED;
                        // Intensity based on where the burn line is (higher in center region)
                        let intensity = 0.0;
                        {
                            // Map Y to 0..1 roughly over stick range [-3.5, 3.5]
                            let yNorm = (currentBurnY + 3.5) / 7.0;
                            yNorm = Math.max(0, Math.min(1, yNorm));
                            // Bell-like curve for mid intensity
                            intensity = 1.0 - Math.pow((yNorm - 0.5) * 2.0, 2.0);
                        }
                        if (Math.random() < intensity * 0.02) {
                            sparklerCrackle(audioCtx);
                        }
                    }
                }
            }
        }

        class Firework {
            constructor(targetPosition, type) {
                this.isExploded = false;
                this.type = type;
                
                const startX = (Math.random() - 0.5) * 10;
                this.position = new THREE.Vector3(startX, -30, 0);
                this.target = targetPosition;
                
                const speed = 0.4;
                this.velocity = new THREE.Vector3()
                    .subVectors(this.target, this.position)
                    .normalize()
                    .multiplyScalar(speed); 

                const geometry = new THREE.BufferGeometry();
                const vertices = new Float32Array([0, 0, 0]);
                geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    map: particleTexture,
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                    transparent: true,
                    opacity: 1,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });

                this.rocket = new THREE.Points(geometry, material);
                this.rocket.position.copy(this.position);
                scene.add(this.rocket);
                
                this.color = material.color;
                
                if(audioCtx) playSoftLaunch();
            }

            update() {
                if (!this.isExploded) {
                    const distanceToTarget = this.rocket.position.distanceTo(this.target);
                    const stepSize = this.velocity.length();

                    if (this.type === 'spark') {
                        trailSystem.add(this.rocket.position, this.color, 1.2);
                    }

                    if (distanceToTarget <= stepSize) {
                        this.rocket.position.copy(this.target);
                        this.explode();
                    } else {
                        this.rocket.position.add(this.velocity);
                        if (this.type !== 'spark' && Math.random() > 0.3) {
                             // Minimal trail
                        }
                    }
                }
            }

            explode() {
                this.isExploded = true;
                scene.remove(this.rocket);
                createExplosion(this.target, this.type, this.color);
            }
        }

        // --- 3. Functions ---

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111116, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 40);
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            particleTexture = createParticleTexture();

            trailSystem = new FireworkTrailSystem(scene, particleTexture);
            sparklerSystem = new SparklerSystem(scene, camera);

            // Volume slider
            const volSlider = document.getElementById('volume-slider');
            if (volSlider) {
                volSlider.value = String(currentVolume);
                volSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value)) {
                        currentVolume = value;
                        if (masterGainNode) {
                            masterGainNode.gain.value = currentVolume;
                        }
                    }
                });
            }

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('pointerdown', onPointerDown, false);
            
            const trigger = document.getElementById('trigger-zone');
            const sidebar = document.getElementById('sidebar');
            trigger.addEventListener('touchstart', () => sidebar.style.left = '0');
            document.addEventListener('touchstart', (e) => {
                if(e.clientX > 220) sidebar.style.left = '-220px';
            });
        }
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (!masterGainNode) {
                masterGainNode = audioCtx.createGain();
                masterGainNode.gain.value = currentVolume;
                masterGainNode.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

		// --- Sparkler Sound: Continuous burn (very low) + micro crackles ---
		function startSparklerBurn(ctx) {
			const noise = ctx.createBufferSource();
			const buffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < data.length; i++) {
				data[i] = (Math.random() * 2 - 1) * 0.15;
			}

			noise.buffer = buffer;
			noise.loop = true;

			const filter = ctx.createBiquadFilter();
			filter.type = 'bandpass';
			filter.frequency.value = 1800;
			filter.Q.value = 0.6;

			const gain = ctx.createGain();
			gain.gain.value = 0.04;

			{
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                noise.connect(filter).connect(gain).connect(output);
            }
			noise.start();

			return { noise, gain };
		}

		function sparklerCrackle(ctx) {
			if (Math.random() > 0.15) return;

			const osc = ctx.createOscillator();
			const gain = ctx.createGain();

			osc.type = 'square';
			osc.frequency.value = 2000 + Math.random() * 1000;

			gain.gain.setValueAtTime(0.001, ctx.currentTime);
			gain.gain.exponentialRampToValueAtTime(0.02, ctx.currentTime + 0.01);
			gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

			{
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                osc.connect(gain).connect(output);
            }
			osc.start();
			osc.stop(ctx.currentTime + 0.1);
		}

        function playSoftLaunch() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const noise = ctx.createBufferSource();
            const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = buffer;
            const filter = ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.setValueAtTime(300, ctx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(3000, ctx.currentTime + 0.4);
            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.2);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
            {
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                noise.connect(filter).connect(gain).connect(output);
            }
            noise.start();
        }

        function playSparkle() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = 1200 + Math.random() * 800;
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.03, ctx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
            {
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                osc.connect(gain).connect(output);
            }
            osc.start();
            osc.stop(ctx.currentTime + 0.15);
        }

        function playSoftBloom() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const now = ctx.currentTime;
            for (let i = 0; i < 6; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 400 + Math.random() * 1200;
                gain.gain.setValueAtTime(0.001, now);
                gain.gain.exponentialRampToValueAtTime(0.08, now + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                {
                    const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                    osc.connect(gain).connect(output);
                }
                osc.start(now + i * 0.015);
                osc.stop(now + 0.8);
            }
        }

        function playShimmer() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = 1800;
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.05, ctx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);
            {
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                osc.connect(gain).connect(output);
            }
            osc.start();
            osc.stop(ctx.currentTime + 1.5);
        }

        function playSoftCrackle() {
            if (!audioCtx) return;
            const ctx = audioCtx;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'square';
            osc.frequency.value = 2000 + Math.random() * 1000;
            gain.gain.setValueAtTime(0.001, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.015, ctx.currentTime + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
            {
                const output = (typeof masterGainNode !== 'undefined' && masterGainNode) ? masterGainNode : ctx.destination;
                osc.connect(gain).connect(output);
            }
            osc.start();
            osc.stop(ctx.currentTime + 0.12);
        }

        function createExplosion(position, type, color) {
            if(audioCtx) {
                if (type === 'bloom') playSoftBloom();
                else if (type === 'drift') playShimmer();
                else if (type === 'scatter') {
                     for(let k=0; k<5; k++) setTimeout(playSoftCrackle, Math.random() * 200);
                }
                else if (type === 'spark') {
                     for(let k=0; k<8; k++) setTimeout(playSoftCrackle, Math.random() * 300);
                }
            }
            
            let particleCount = 0;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];
            const sizes = [];
            const decays = [];
            const targetSizes = []; 

            let baseSpeed = 0.5;
            
            switch (type) {
                case 'spark': particleCount = 100; baseSpeed = 0.2; break;
                case 'bloom': particleCount = 200; baseSpeed = 0.15; break;
                case 'drift': particleCount = 100; baseSpeed = 0.08; break;
                case 'scatter': particleCount = 80; baseSpeed = 0.25; break;
            }

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                const c = new THREE.Color().copy(color);
                c.offsetHSL(0, 0, (Math.random() - 0.5) * 0.2);
                colors.push(c.r, c.g, c.b);
                const v = new THREE.Vector3();
                
                if (type === 'bloom') {
                    const phi = Math.PI * (3 - Math.sqrt(5)); 
                    const y = 1 - (i / (particleCount - 1)) * 2; 
                    const radius = Math.sqrt(1 - y * y);
                    const theta = phi * i;
                    v.x = Math.cos(theta) * radius * baseSpeed;
                    v.y = y * baseSpeed;
                    v.z = Math.sin(theta) * radius * baseSpeed;
                } 
                else if (type === 'spark') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * baseSpeed;
                    v.x = r * Math.sin(phi) * Math.cos(theta);
                    v.y = r * Math.sin(phi) * Math.sin(theta);
                    v.z = r * Math.cos(phi);
                }
                else if (type === 'drift') {
                    const theta = Math.random() * Math.PI * 2;
                    const r = Math.random() * baseSpeed;
                    v.x = r * Math.cos(theta) * 1.4; 
                    v.y = (Math.random() - 0.2) * 0.2; 
                    v.z = r * Math.sin(theta) * 1.4;
                }
                else {
                    v.set((Math.random()-0.5)*2, (Math.random()-0.5)*2, (Math.random()-0.5)*2)
                     .normalize().multiplyScalar(Math.random() * baseSpeed * 2);
                }

                velocities.push(v.x, v.y + 0.12, v.z);
                const finalSize = (Math.random() * 1.5 + 0.5) * (type === 'spark' ? 2 : 1);
                targetSizes.push(finalSize);
                if (type === 'bloom') sizes.push(0.1); else sizes.push(finalSize);
                decays.push(0.0008 + Math.random() * 0.003);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.0,
                map: particleTexture,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            particles.push({
                mesh: particleSystem,
                velocities: velocities,
                targetSizes: targetSizes,
                decays: decays,
                type: type,
                life: 1.0,
                age: 0
            });
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function toggleAutoPlay() {
            initAudio();
            isAutoPlay = !isAutoPlay;
            if(sparklerSystem && sparklerSystem.active) sparklerSystem.stop();
            
            const btnAuto = document.getElementById('btn-autoplay');
            const manualBtns = document.querySelectorAll('.fw-option:not(#btn-autoplay)');
            manualBtns.forEach(b => b.classList.remove('active'));
            
            if (isAutoPlay) {
                btnAuto.classList.add('active');
                btnAuto.innerText = "Pause"; 
                autoPlayTimer = 30; 
            } else {
                btnAuto.classList.remove('active');
                btnAuto.innerText = "Stay and watch"; 
                const currentBtn = document.getElementById('opt-' + currentType);
                if(currentBtn) currentBtn.classList.add('active');
            }
        }

        function setFireworkType(type) {
            initAudio();
            isAutoPlay = false;
            if(sparklerSystem && sparklerSystem.active) sparklerSystem.stop();

            currentType = type;
            
            const btnAuto = document.getElementById('btn-autoplay');
            btnAuto.classList.remove('active');
            btnAuto.innerText = "Stay and watch"; 
            
            const buttons = document.querySelectorAll('.fw-option:not(#btn-autoplay)');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const activeBtn = document.getElementById('opt-' + type);
            if(activeBtn) activeBtn.classList.add('active');
        }
        
        function launchSparkler() {
            initAudio();
            isAutoPlay = false;
            const btnAuto = document.getElementById('btn-autoplay');
            btnAuto.classList.remove('active');
            btnAuto.innerText = "Stay and watch";

            const buttons = document.querySelectorAll('.fw-option:not(#btn-autoplay)');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const sparklerBtn = document.getElementById('opt-sparkler');
            sparklerBtn.classList.add('active');

            if (sparklerSystem) sparklerSystem.start();
        }
        
        function launchRandomFirework() {
            const types = ['spark', 'bloom', 'drift', 'scatter'];
            const randomType = types[Math.floor(Math.random() * types.length)];
            const x = (Math.random() - 0.5) * 12; 
            const y = Math.random() * 8 + 4; 
            const target = new THREE.Vector3(x, y, 0);
            fireworks.push(new Firework(target, randomType));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(sparklerSystem && sparklerSystem.mesh) {
               sparklerSystem.mesh.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
            }
        }

        function onPointerDown(event) {
            initAudio();

			const sidebar = document.getElementById('sidebar');
			if (sidebar && (sidebar.contains(event.target) || (event.clientX < 220 && getComputedStyle(sidebar).left === '0px'))) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeZ, target);
            if(target) fireworks.push(new Firework(target, currentType));
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isAutoPlay) {
                if (Math.random() < 0.01) playSparkle();
                autoPlayTimer--;
                if (autoPlayTimer <= 0) {
                    launchRandomFirework();
                    autoPlayTimer = Math.random() * 120 + 60;
                }
            }

            trailSystem.update();
            if (sparklerSystem) sparklerSystem.update();

            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update();
                if (fireworks[i].isExploded) fireworks.splice(i, 1);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const positions = p.mesh.geometry.attributes.position.array;
                const sizes = p.mesh.geometry.attributes.size.array;
                const colors = p.mesh.geometry.attributes.color.array;
                
                let drag = 0.99; 
                let grav = -0.006; 

                if (p.type === 'bloom') { drag = 0.985; grav = -0.004; }
                else if (p.type === 'drift') { drag = 0.98; grav = -0.001; }
                else if (p.type === 'scatter') { drag = 0.995; }

                p.age++;

                for (let j = 0; j < p.velocities.length; j += 3) {
                    const vertexIndex = j / 3;
                    p.velocities[j + 1] += grav;
                    p.velocities[j] *= drag;
                    p.velocities[j + 1] *= drag;
                    p.velocities[j + 2] *= drag;
                    positions[j] += p.velocities[j];
                    positions[j + 1] += p.velocities[j + 1];
                    positions[j + 2] += p.velocities[j + 2];

                    if (p.type === 'spark' && p.life > 0.2) {
                        const pos = new THREE.Vector3(positions[j], positions[j+1], positions[j+2]);
                        const col = new THREE.Color(colors[j], colors[j+1], colors[j+2]);
                        trailSystem.add(pos, col, 0.5);
                    }

                    if (p.type === 'bloom' && p.age < 60) {
                        const targetSize = p.targetSizes[vertexIndex];
                        const progress = p.age / 60;
                        const ease = 1 - Math.pow(1 - progress, 3);
                        sizes[vertexIndex] = targetSize * ease;
                    }
                }

                p.life -= 0.002; 
                p.mesh.material.opacity = p.life;
                p.mesh.geometry.attributes.position.needsUpdate = true;
                if (p.type === 'bloom') p.mesh.geometry.attributes.size.needsUpdate = true;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>