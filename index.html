<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumina - 3D Firework Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        
        /* Custom Scrollbar for sidebar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; borderRadius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }

        .glass-panel {
            background: rgba(20, 20, 25, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group { margin-bottom: 1.5rem; }
        
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }

        /* Active state for type buttons */
        .type-btn.active {
            background-color: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
            box-shadow: 0 0 15px rgba(255,255,255,0.1);
        }

        /* Sound Toggle */
        .sound-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.2s;
        }
        .sound-btn.active {
            background: rgba(16, 185, 129, 0.2);
            border-color: rgba(16, 185, 129, 0.5);
            color: #10b981;
        }
    </style>
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="text-gray-300">

    <!-- UI Overlay -->
    <div id="ui-container" class="absolute top-0 left-0 h-full z-10 flex pointer-events-none">
        
        <!-- Sidebar -->
        <div class="glass-panel w-72 h-full p-6 pointer-events-auto overflow-y-auto transform transition-transform duration-300 ease-in-out" id="sidebar">
            <div class="flex justify-between items-start mb-8">
                <div>
                    <h1 class="text-2xl font-bold text-white mb-1 tracking-wider">LUMINA</h1>
                    <p class="text-xs text-gray-500 uppercase tracking-widest">Interactive Pyro Sim</p>
                </div>
                <button id="sound-toggle" class="sound-btn active p-2 rounded-full hover:bg-white/10" title="Toggle Sound">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                    </svg>
                </button>
            </div>

            <!-- Firework Types -->
            <div class="control-group">
                <label class="block text-xs font-semibold uppercase text-gray-400 mb-3">Pattern Type</label>
                <div class="grid grid-cols-2 gap-2">
                    <button class="type-btn active px-3 py-2 rounded bg-gray-800/50 border border-transparent hover:border-gray-600 transition-all text-sm text-left" data-type="sphere">Sphere</button>
                    <button class="type-btn px-3 py-2 rounded bg-gray-800/50 border border-transparent hover:border-gray-600 transition-all text-sm text-left" data-type="ring">Saturn Ring</button>
                    <button class="type-btn px-3 py-2 rounded bg-gray-800/50 border border-transparent hover:border-gray-600 transition-all text-sm text-left" data-type="heart">Heart</button>
                    <button class="type-btn px-3 py-2 rounded bg-gray-800/50 border border-transparent hover:border-gray-600 transition-all text-sm text-left" data-type="spiral">Galaxy</button>
                    <button class="type-btn px-3 py-2 rounded bg-gray-800/50 border border-transparent hover:border-gray-600 transition-all text-sm text-left col-span-2" data-type="random">Randomize</button>
                </div>
            </div>

            <!-- Sliders -->
            <div class="control-group">
                <div class="flex justify-between mb-1">
                    <label class="text-xs font-semibold uppercase text-gray-400">Hue Base</label>
                    <span id="hue-val" class="text-xs font-mono text-white">Random</span>
                </div>
                <input type="range" id="hue-slider" min="-1" max="360" value="-1" class="w-full">
                <div class="h-1 w-full mt-2 rounded bg-gradient-to-r from-red-500 via-green-500 to-blue-500 opacity-50"></div>
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-1">
                    <label class="text-xs font-semibold uppercase text-gray-400">Explosion Size</label>
                    <span id="size-val" class="text-xs font-mono text-white">1.0</span>
                </div>
                <input type="range" id="size-slider" min="0.5" max="2.5" step="0.1" value="1.0" class="w-full">
            </div>

            <div class="control-group">
                <div class="flex justify-between mb-1">
                    <label class="text-xs font-semibold uppercase text-gray-400">Launch Speed</label>
                    <span id="speed-val" class="text-xs font-mono text-white">High</span>
                </div>
                <input type="range" id="speed-slider" min="0.5" max="1.5" step="0.1" value="1.0" class="w-full">
            </div>

            <!-- Instructions -->
            <div class="mt-8 p-4 bg-gray-800/30 rounded border border-gray-700/50">
                <h3 class="text-white text-sm font-bold mb-2">Controls</h3>
                <ul class="text-xs space-y-2 text-gray-400">
                    <li class="flex items-start">
                        <span class="bg-gray-700 text-white rounded px-1.5 py-0.5 mr-2 text-[10px]">L-CLICK</span>
                        <span>Rotate Camera</span>
                    </li>
                    <li class="flex items-start">
                        <span class="bg-blue-600 text-white rounded px-1.5 py-0.5 mr-2 text-[10px]">R-CLICK</span>
                        <span>Drag to Aim & Fire</span>
                    </li>
                    <li class="flex items-start">
                        <span class="bg-gray-700 text-white rounded px-1.5 py-0.5 mr-2 text-[10px]">SCROLL</span>
                        <span>Zoom</span>
                    </li>
                </ul>
            </div>
            
            <div class="mt-4 text-center">
                 <button id="auto-fire" class="w-full py-2 bg-gradient-to-r from-purple-600 to-blue-600 rounded text-white text-sm font-bold shadow-lg hover:shadow-purple-500/30 transition-shadow">
                    Start Auto-Show
                 </button>
            </div>
        </div>
    </div>

    <!-- Instructions Overlay (Fades out) -->
    <div id="tutorial" class="absolute inset-0 flex items-center justify-center pointer-events-none z-20 transition-opacity duration-1000">
        <div class="bg-black/60 backdrop-blur-sm p-6 rounded-xl border border-white/10 text-center animate-pulse">
            <p class="text-white text-lg font-light">Right-Click & Drag to Launch</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const config = {
            type: 'sphere',
            hue: -1, // -1 is random
            explosionSize: 1.0,
            launchSpeed: 1.0,
            gravity: 9.8,
            particleCount: 400,
            soundEnabled: true
        };

        // --- Sound System ---
        // Uses Web Audio API to synthesize sounds (no external files needed)
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        const SoundSystem = {
            resume: () => {
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            },
            
            playLaunch: () => {
                if (!config.soundEnabled) return;
                const ctx = audioCtx;
                
                // Provided "playSoftLaunch" implementation
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.5, ctx.sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                noise.buffer = buffer;

                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(300, ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(3000, ctx.currentTime + 0.4);

                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.001, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.15, ctx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);

                noise.connect(filter).connect(gain).connect(ctx.destination);
                noise.start();
            },

            playSparkle: () => {
                if (!config.soundEnabled) return;
                const ctx = audioCtx;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.value = 1200 + Math.random() * 800;

                gain.gain.setValueAtTime(0.001, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.03, ctx.currentTime + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);

                osc.connect(gain).connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.15);
            },
            
            // For Sphere / Heart
            playSoftBloom: () => {
                if (!config.soundEnabled) return;
                const ctx = audioCtx;
                const now = ctx.currentTime;

                for (let i = 0; i < 6; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = 400 + Math.random() * 1200;

                    gain.gain.setValueAtTime(0.001, now);
                    gain.gain.exponentialRampToValueAtTime(0.08, now + 0.03);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

                    osc.connect(gain).connect(ctx.destination);
                    osc.start(now + i * 0.015);
                    osc.stop(now + 0.8);
                }
            },

            // For Ring
            playShimmer: () => {
                if (!config.soundEnabled) return;
                const ctx = audioCtx;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.value = 1800;

                gain.gain.setValueAtTime(0.001, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.05, ctx.currentTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);

                osc.connect(gain).connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 1.5);
            },

            // Low-level crackle sound
            playSoftCrackle: () => {
                if (!config.soundEnabled) return;
                if (Math.random() > 0.4) return;
                const ctx = audioCtx;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.type = 'square';
                osc.frequency.value = 2000 + Math.random() * 1000;

                gain.gain.setValueAtTime(0.001, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.015, ctx.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);

                osc.connect(gain).connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.12);
            },

            // Trigger for Spiral
            playCrackleBurst: () => {
                // Trigger multiple small crackles
                for(let i=0; i<10; i++) {
                    setTimeout(() => SoundSystem.playSoftCrackle(), i * 50);
                }
            }
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 50);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Prevent going below ground
        controls.minDistance = 10;
        controls.maxDistance = 150;

        // --- Ground & Environment ---
        const gridHelper = new THREE.GridHelper(200, 50, 0x333333, 0x111111);
        scene.add(gridHelper);

        // Simple ground plane for raycasting
        const planeGeometry = new THREE.PlaneGeometry(500, 500);
        const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
        const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        groundPlane.rotation.x = -Math.PI / 2;
        scene.add(groundPlane);

        // --- Texture Generation for Particles ---
        function getParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        const particleTexture = getParticleTexture();

        // --- Firework Classes ---

        class Particle {
            constructor(x, y, z, color, type = 'spark') {
                this.position = new THREE.Vector3(x, y, z);
                this.velocity = new THREE.Vector3();
                this.acceleration = new THREE.Vector3(0, -config.gravity * 0.5, 0); // Reduced gravity for effect
                this.color = new THREE.Color(color);
                this.life = 1.0;
                this.decay = Math.random() * 0.015 + 0.01;
                this.size = Math.random() * 2 + 1;
                
                if (type === 'rocket') {
                    this.decay = 0; // Managed manually
                    this.acceleration.set(0, -5, 0); // Rockets have less gravity initially
                }
            }

            update(dt) {
                this.velocity.addScaledVector(this.acceleration, dt);
                this.position.addScaledVector(this.velocity, dt);
                
                // Drag
                this.velocity.multiplyScalar(0.98);

                this.life -= this.decay;
            }
        }

        class Firework {
            constructor(startPos, targetPos, hue, pattern) {
                this.isDead = false;
                this.hue = hue;
                this.pattern = pattern;
                this.particles = [];
                
                // Rocket Phase
                this.phase = 'rocket';
                
                const start = startPos.clone();
                // Calculate velocity to hit target height approx
                const height = Math.max(20, targetPos.y); 
                // Simple physics estimation for initial velocity to reach height
                const vy = Math.sqrt(2 * 5 * height) * config.launchSpeed; 
                
                // Direction towards target (horizontal)
                const dir = new THREE.Vector3().subVectors(targetPos, startPos);
                dir.y = 0;
                const dist = dir.length();
                dir.normalize();
                
                // Time to peak roughly vy / gravity
                const t = vy / 5;
                const vx = dist / t;
                
                this.rocket = new Particle(start.x, start.y, start.z, `hsl(${hue}, 100%, 80%)`, 'rocket');
                this.rocket.velocity.set(dir.x * vx, vy, dir.z * vx);
                this.rocket.size = 4;
                
                // Sound
                SoundSystem.playLaunch();

                // Trail particles container
                this.trail = [];
            }

            explode() {
                this.phase = 'explosion';
                const pos = this.rocket.position;
                const count = config.particleCount;
                
                // Trigger Sound based on Type
                if (this.pattern === 'sphere' || this.pattern === 'heart') {
                    SoundSystem.playSoftBloom();
                } else if (this.pattern === 'ring') {
                    SoundSystem.playShimmer();
                } else if (this.pattern === 'spiral') {
                    SoundSystem.playCrackleBurst();
                } else {
                    // Random fallback
                    SoundSystem.playSoftBloom();
                }

                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const sizes = [];

                // Pattern Logic
                for (let i = 0; i < count; i++) {
                    const p = new Particle(pos.x, pos.y, pos.z, `hsl(${this.hue}, 100%, 60%)`);
                    
                    // Velocity Generation based on Pattern
                    let v = new THREE.Vector3();
                    const speed = (Math.random() * 15 + 15) * config.explosionSize;

                    if (this.pattern === 'sphere' || this.pattern === 'random') {
                        v.set(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(speed);
                    } 
                    else if (this.pattern === 'ring') {
                        const angle = Math.random() * Math.PI * 2;
                        // Flatten Y, expand XZ
                        v.set(Math.cos(angle), (Math.random()-0.5)*0.1, Math.sin(angle)).normalize().multiplyScalar(speed);
                    }
                    else if (this.pattern === 'heart') {
                        // Parametric heart equations
                        const t = Math.random() * Math.PI * 2;
                        const scale = 0.5;
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                        
                        v.set(x * scale, y * scale, (Math.random()-0.5) * 2).multiplyScalar(config.explosionSize);
                    }
                    else if (this.pattern === 'spiral') {
                        const t = i / count * Math.PI * 10; // 5 turns
                        const r = i / count;
                        v.set(
                            Math.cos(t) * r, 
                            (Math.random() - 0.5) * 0.5, 
                            Math.sin(t) * r
                        ).normalize().multiplyScalar(speed);
                        
                        // Rotate spiral to look cool
                        v.applyAxisAngle(new THREE.Vector3(1,0,0), Math.PI/4);
                    }

                    p.velocity = v;
                    
                    // Color variation
                    const color = new THREE.Color();
                    color.setHSL((this.hue + Math.random() * 20 - 10) / 360, 1.0, 0.6);
                    p.color = color;
                    p.life = 1.0 + Math.random() * 0.5; // Staggered death

                    this.particles.push(p);
                }
            }

            update(dt) {
                if (this.phase === 'rocket') {
                    this.rocket.update(dt);
                    
                    // Add trail
                    if (Math.random() > 0.5) {
                        const t = new Particle(
                            this.rocket.position.x, 
                            this.rocket.position.y, 
                            this.rocket.position.z, 
                            `hsl(${this.hue}, 50%, 50%)`
                        );
                        t.velocity.copy(this.rocket.velocity).multiplyScalar(-0.1); // Backward drift
                        t.velocity.x += (Math.random()-0.5);
                        t.velocity.z += (Math.random()-0.5);
                        t.life = 0.3;
                        t.size = 2;
                        this.trail.push(t);
                    }

                    // Check for apex (vertical velocity low) or ground hit
                    if (this.rocket.velocity.y < 2) {
                        this.explode();
                    }
                } else {
                    // Explosion phase
                    for (let p of this.particles) {
                        p.update(dt);
                    }
                    // Remove dead particles
                    this.particles = this.particles.filter(p => p.life > 0);
                    if (this.particles.length === 0) this.isDead = true;
                }

                // Update trail
                for (let t of this.trail) {
                    t.update(dt);
                }
                this.trail = this.trail.filter(t => t.life > 0);
            }

            getGeometryData(positions, colors, sizes) {
                // Collect all visible points (rocket + trail + explosion)
                const add = (p) => {
                    positions.push(p.position.x, p.position.y, p.position.z);
                    colors.push(p.color.r, p.color.g, p.color.b);
                    sizes.push(p.size * p.life); // Fade out size
                };

                if (this.phase === 'rocket') {
                    add(this.rocket);
                }
                
                this.trail.forEach(t => add(t));
                this.particles.forEach(p => add(p));
            }
        }

        // --- State ---
        const fireworks = [];
        let autoFireInterval = null;

        // --- Main Geometry System ---
        // Using a single large BufferGeometry for all particles is more efficient than sprites
        const maxParticles = 20000;
        const particleGeometry = new THREE.BufferGeometry();
        const pPos = new Float32Array(maxParticles * 3);
        const pCol = new Float32Array(maxParticles * 3);
        const pSize = new Float32Array(maxParticles);
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(pCol, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(pSize, 1));

        const particleMaterial = new THREE.PointsMaterial({
            size: 1.0,
            vertexColors: true,
            map: particleTexture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            sizeAttenuation: true
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        particleSystem.frustumCulled = false; // Always render
        scene.add(particleSystem);


        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let dragStartPoint = new THREE.Vector3();
        let currentDragPoint = new THREE.Vector3();
        
        // Trajectory Line
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
        const lineMat = new THREE.LineDashedMaterial({ 
            color: 0xffffff, 
            dashSize: 1, 
            gapSize: 0.5,
            opacity: 0.5,
            transparent: true
        });
        const trajectoryLine = new THREE.Line(lineGeo, lineMat);
        trajectoryLine.computeLineDistances();
        scene.add(trajectoryLine);
        trajectoryLine.visible = false;

        function getIntersects(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            return raycaster.intersectObject(groundPlane);
        }

        function launchFirework(targetPos) {
            let h = config.hue;
            if (h === -1) h = Math.floor(Math.random() * 360);
            
            let p = config.type;
            if (p === 'random') {
                const types = ['sphere', 'ring', 'heart', 'spiral'];
                p = types[Math.floor(Math.random() * types.length)];
            }

            // Launch from somewhat center but offset slightly random
            const startPos = new THREE.Vector3((Math.random()-0.5)*5, 0, (Math.random()-0.5)*5);
            
            // Adjust height of target for better visuals if clicked on ground
            const adjustedTarget = targetPos.clone();
            if (adjustedTarget.y < 10) adjustedTarget.y = 30 + Math.random() * 20;

            fireworks.push(new Firework(startPos, adjustedTarget, h, p));
        }

        window.addEventListener('contextmenu', e => e.preventDefault()); // Disable right click menu

        window.addEventListener('mousedown', (e) => {
            // Initialize audio on interaction
            SoundSystem.resume();

            // Right click or Shift+Click to drag
            if (e.button === 2 || (e.button === 0 && e.shiftKey)) {
                const intersects = getIntersects(e);
                if (intersects.length > 0) {
                    isDragging = true;
                    dragStartPoint.copy(intersects[0].point);
                    currentDragPoint.copy(intersects[0].point);
                    controls.enabled = false; // Disable orbit while aiming
                    
                    trajectoryLine.visible = true;
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const intersects = getIntersects(e);
                if (intersects.length > 0) {
                    currentDragPoint.copy(intersects[0].point);
                    
                    // Update Line visual
                    // The line goes from start point UP into the air based on drag distance
                    const dist = dragStartPoint.distanceTo(currentDragPoint);
                    
                    // Visualize trajectory: Line from start to estimated explosion point
                    // We simulate user "pulling back" to aim higher
                    const positions = trajectoryLine.geometry.attributes.position.array;
                    positions[0] = 0; positions[1] = 0; positions[2] = 0; // Relative to world 0,0,0? No.
                    
                    // Let's make line represent the path from Center to Target
                    // Target is: DragStart + (DragStart - CurrentDrag) * scale
                    const pullVector = new THREE.Vector3().subVectors(dragStartPoint, currentDragPoint);
                    const target = dragStartPoint.clone().add(pullVector.multiplyScalar(2));
                    target.y = Math.max(20, Math.abs(pullVector.length() * 2) + 20); // Height based on drag

                    trajectoryLine.geometry.setFromPoints([new THREE.Vector3(0,0,0), target]);
                    trajectoryLine.computeLineDistances();
                }
            }
        });

        window.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                controls.enabled = true;
                trajectoryLine.visible = false;
                
                // Calculate target based on drag
                const pullVector = new THREE.Vector3().subVectors(dragStartPoint, currentDragPoint);
                const target = dragStartPoint.clone().add(pullVector.multiplyScalar(2));
                target.y = Math.max(20, Math.abs(pullVector.length() * 2) + 20);

                launchFirework(target);
                
                // Hide tutorial
                const tut = document.getElementById('tutorial');
                if(tut) tut.style.opacity = '0';
            }
        });


        // --- UI Logic ---
        const soundBtn = document.getElementById('sound-toggle');
        soundBtn.addEventListener('click', () => {
            config.soundEnabled = !config.soundEnabled;
            if(config.soundEnabled) {
                soundBtn.classList.add('active');
                SoundSystem.resume();
            } else {
                soundBtn.classList.remove('active');
            }
        });

        document.querySelectorAll('.type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.type = btn.dataset.type;
            });
        });

        const hueSlider = document.getElementById('hue-slider');
        const hueVal = document.getElementById('hue-val');
        hueSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            config.hue = val;
            hueVal.textContent = val === -1 ? "Random" : val;
            hueVal.style.color = val === -1 ? 'white' : `hsl(${val}, 100%, 70%)`;
        });

        document.getElementById('size-slider').addEventListener('input', (e) => {
            config.explosionSize = parseFloat(e.target.value);
            document.getElementById('size-val').textContent = config.explosionSize.toFixed(1);
        });
        
        document.getElementById('speed-slider').addEventListener('input', (e) => {
            config.launchSpeed = parseFloat(e.target.value);
            document.getElementById('speed-val').textContent = e.target.value > 1.2 ? "Max" : (e.target.value < 0.8 ? "Low" : "Normal");
        });

        const autoBtn = document.getElementById('auto-fire');
        autoBtn.addEventListener('click', () => {
            // Ensure sound is active if user clicks auto
            SoundSystem.resume();
            
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
                autoFireInterval = null;
                autoBtn.textContent = "Start Auto-Show";
                autoBtn.classList.remove('from-red-600', 'to-orange-600');
                autoBtn.classList.add('from-purple-600', 'to-blue-600');
            } else {
                launchFirework(new THREE.Vector3(0, 40, 0)); // Instant fire
                autoFireInterval = setInterval(() => {
                    const x = (Math.random() - 0.5) * 80;
                    const z = (Math.random() - 0.5) * 80;
                    const y = 30 + Math.random() * 40;
                    launchFirework(new THREE.Vector3(x, y, z));
                    
                    // Add sparkly ambient sound occasionally
                    if (Math.random() < 0.3) {
                        SoundSystem.playSparkle();
                    }
                }, 800);
                autoBtn.textContent = "Stop Auto-Show";
                autoBtn.classList.remove('from-purple-600', 'to-blue-600');
                autoBtn.classList.add('from-red-600', 'to-orange-600');
            }
        });


        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = Math.min(clock.getDelta(), 0.1);

            controls.update();

            // Update Fireworks
            for (let i = fireworks.length - 1; i >= 0; i--) {
                fireworks[i].update(dt);
                if (fireworks[i].isDead) {
                    fireworks.splice(i, 1);
                }
            }

            // Update Geometry
            let posIdx = 0;
            let colIdx = 0;
            let sizeIdx = 0;
            
            // Re-use arrays to avoid GC
            const positions = [];
            const colors = [];
            const sizes = [];

            // We need to flatten data into arrays. 
            // Optimizing: Using simple array push here for readability, 
            // but in heavy production, we'd write directly to Float32Array
            
            for (let fw of fireworks) {
                fw.getGeometryData(positions, colors, sizes);
            }

            // Update BufferAttributes
            // Note: If particle count exceeds maxParticles, it will truncate.
            const count = Math.min(positions.length / 3, maxParticles);
            
            particleGeometry.setDrawRange(0, count);
            
            const posAttr = particleGeometry.attributes.position;
            const colAttr = particleGeometry.attributes.color;
            const sizeAttr = particleGeometry.attributes.size;

            for (let i = 0; i < count; i++) {
                posAttr.setXYZ(i, positions[i*3], positions[i*3+1], positions[i*3+2]);
                colAttr.setXYZ(i, colors[i*3], colors[i*3+1], colors[i*3+2]);
                sizeAttr.setX(i, sizes[i]);
            }

            posAttr.needsUpdate = true;
            colAttr.needsUpdate = true;
            sizeAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>